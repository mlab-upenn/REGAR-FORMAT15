data;
# Graphs 1 (Bundle) 2 (Atrial flutter) 3 (AVNRT) and 4 (PVC)
# Rules R1 (remove loops) R2 (remove inessential structures) R3 (merge self-activation with sensing) 
# element = vertex or edge of the graph
param nelements      := 72;
set ELEMENTS     := 1 2 3 4 5 6 7 8 9 10 
					11 12 13 14 15 16 17 18 19 20 
					21 22 23 24 25 26 27 28 29 30
					31 32 33 34 35 36 37 38 39 40
					41 42 43 44 45 46 47 48 49 50
					51 52 53 54 55 56 57 58 59 60
					61 62 63 64 65 66 67 68 69 70
					71 72
					;
set RULES        := R1 R5;#R2 ;
set SUBGRAPHS    := SL2 SL3 SIn1 SIn2 SIn3 SSS2 SSS4 ;
param N         	 := 4;
set TIME0        := 0 1 2 3 4;
set TIME 		 := 1 2 3 4;
set ZERO         := 0;

# The initial values of vertex parameters
# Here I show only one parameter per element
param Px0 :=
    1  5    2  5  	3 5  	4 5  	5 5    	6 4    	7 4    	8 4    	9 4    	 10 4
    11 4    12 4    13 4    14 4    15 4    16 4    17 4    18 4    19 4     20 4
    21 4    22 4    23 4    24 4    25 4    26 4    27 4    28 4    29 4     30 4
    31 4    32 4    33 4    34 4    35 4    36 4    37 4    38 4    39 4     40 4
    41 4    42 4    43 4    44 4    45 4    46 4    47 4    48 4    49 4     50 4
    51 4    52 4    53 4    54 4    55 4    56 4    57 4    58 4    59 4     60 4
    61 4    62 4    63 4    64 4    65 4    66 4    67 4    68 4    69 4     70 4
    71 4    72 4 
    ;

# Terms for the linear predicate Phi
param C := R1 600  R4 600 R5 600;
param B : 
       1   2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19 20 21 22 23 24 25 26 27 28 29 30	31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50	51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70	71 72:=
 R1    1   1  1  1  1  1  1  1  1  1    1   1   1   1   1   1   1   1   1  1 1   1  1  1  1  1  1  1  1  1    1   1   1   1   1   1   1   1   1  1 1   1  1  1  1  1  1  1  1  1    1   1   1   1   1   1   1   1   1  1    1  1    1   1   1   1   1   1   1   1   1  1 
 R4    1   1  1  1  1  1  1  1  1  1    1   1   1   1   1   1   1   1   1  1 1   1  1  1  1  1  1  1  1  1    1   1   1   1   1   1   1   1   1  1 1   1  1  1  1  1  1  1  1  1    1   1   1   1   1   1   1   1   1  1    1  1    1   1   1   1   1   1   1   1   1  1 
 R5    1   1  1  1  1  1  1  1  1  1    1   1   1   1   1   1   1   1   1  1 1   1  1  1  1  1  1  1  1  1    1   1   1   1   1   1   1   1   1  1 1   1  1  1  1  1  1  1  1  1    1   1   1   1   1   1   1   1   1  1    1  1    1   1   1   1   1   1   1   1   1  1
 ;

# Preserved elements
# An element is identified by a unique integer (basically, 
# we just count the element in the graoh G)
set VPHI := 1 6 65 68 20 23 42 45;
# Element list of induced subgraphs. 
# (s,x) means x (given by its identity in G) is in subgraph Ks
# Note that here we only list the elements of Ks that will be destroyed by applying the rule. Thus if a rule removes elements of a loop Ks,
# we only list those elements that are deleted from Ks and not all of them.
set KX := 
	(SL2,   *) 35 28 34 29 33 30 32 
	(SL3,   *) 54 50 55 51 56 52 57
	(SIn1,  *) 2 11 12 3 16 7 17 8 18 9 19 10
	(SIn2,  *) 35 28 34 29 33 30 32 41 24 36 25 37 26 38 27
	(SIn3,  *) 54 50 55 51 56 52 57 60 46 61 47 62 48 63 49
	(SSS2,  *) 28 35 
	(SSS4,  *) 64 69  	
	;
	
# (R,Ks) in KRULES means that subgraph Ks is a stage for R
set KRULES := 
	(R1, *) SL2 SL3
	(R5, *) SSS2 SSS4
	;
	
# DESTROYED[i,s] are the Stages destroyed by application of R_i to ssubgraph s
set DESTROYED[R1, SL2]  := SL2 SIn2 SSS2;
set DESTROYED[R1, SL3]  := SL3 SIn3;
#set DESTROYED[R2, SIn1] := SIn1;
#set DESTROYED[R2, SIn2] := SIn2 SL2 SSS2;
#set DESTROYED[R2, SIn3] := SIn3 SL3;
set DESTROYED[R5, SSS2] := SSS2 SL2 SIn2;
set DESTROYED[R5, SSS4] := SSS4 ;  
# Abstractness for every rule
# 
# deltaRS gives how many elements are removed by application of a rule
param deltaRS := R1 7  R5 2;#R2 12 
