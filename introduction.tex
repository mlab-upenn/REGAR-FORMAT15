\section{Introduction}
\label{introduction}

Implantable medical devices like pacemakers are designed to improve undesired physiological conditions with very little human intervention. 
Their ability of autonomously affect the physiological state of the patient makes the medical devices safety-critical, and sufficient evidence for their safety and efficacy should be provided before the devices can be implanted in the patients. 
As more functionality is added to the devices, the complexity of the software component of the device is increasing dramatically, leading to an increasing number of potential safety violations due to software bugs. 
\todo{give recall statistics}
In what follows, we use the word `device' to refer both to the hardware and the software of the device.

There are two categories of device bugs: 
first, the device may fail to conform to its \emph{specification}, i.e. the prescription of how it should react to certain inputs.  
Secondly, even if it conforms to its specification, the device may fail to improve the health of the patient as promised. 
The improved state of health is captured in the \emph{physiological requirements}; e.g., for a pacemaker, the heart rate should always be below a certain threshold. 
%In what follows, the word `requirement' always refers to such physiological requirements.
Note that requirements are about \emph{the closed-loop system}: they prescribe the behavior of both device and environment (e.g. both pacemaker and heart).

Bugs in the first category (non-conformance to specification) are detected via extensive open-loop testing where a set of input sequences is fed to the device, and its output is observed to see if it matches the expected output.
Bugs in the second category (violation of physiological requirements), on the other hand, require the availability of the closed-loop system: e.g., the heart and the pacemaker. 
In the medical device industry, clinical trials amount to a closed-loop test of the device. 
In a clinical trial, the actual device is implanted in a human subject and its operation tested over a certain duration.
Unfortunately, clinical trials can only cover a very limited range of physiological conditions due to their extremely high cost. 
\todo{give dollar amount}
Moreover, clinical trials are often conducted at the last design stage. Fixing bugs at this stage is very costly.

On the other hand, using a virtual model of the device's environment, we can conduct \emph{model-based clinical trials}: i.e., the device (or a model thereof) is connected to a virtual model of the environment and this virtual closed loop is verified.
Depending on the formalism used to model the environment (and device) and the language used to express the requirements, this allows the usage of formal methods to perform the verification.
Environment modeling introduces new challenges and issues that do not arise when modeling the device alone, and this paper aims at addressing these issues in the context of pacemaker verification.
The proposed method is also generalizable to other contexts where closed-loop formal verification is desired.
In the rest of this paper, we speak therefore of pacemaker as the Device Under Verification (DUV) and of the heart as being the environment, but it is understood that the discussion carries more broadly, with possible domain-specific adjustments.

The first challenge in closed-loop verification of pacemakers is that the human heart displays a large number of different conditions, henceforth referred to as `physiological conditions'.
E.g., one heart may display \emph{atrial fibrillation} where the upper chambers of the heart (the atria) produce an exceedingly fast beat that prevents proper blood pumping.
Another heart may display Premature Ventricular Contraction (PVC) where a location in the ventricles produces electrical impulses at erratic time instants.
Each such condition will require its own formal model, and some models may display more than one condition.
In this paper, we build such a set of formal heart models using the timed automata formalism in Section ???.
Rather than perform verification on each model separately, we seek a method that can combine models, and perform model checking on the merged model. 
The combination of models must be such that if the merged model is correct (according to the requirements) then so is every model that was combined into it.
We present \emph{abstraction rules} in Section ?? which allow us to do precisely that.

This initial set of models will necessarily be \emph{incomplete} because the number of physiological conditions is too large, and some of the conditions are too ill-understood for modeling.
Thus, unlike system modeling where one typically starts from one ground truth model to be verified, our starting point is an \emph{incomplete set of models}.
Because of this incompleteness, we seek abstraction rules that introduce new \emph{physiologically meaningful} behavior which might actually be produced by heart models not in the initial set.
These then correspond to heart conditions not taken explicitly into account. 
This provides a second motivation for the domain-specific abstraction rules $R$ in Section ???, which can be thought of as relaxations of the conditions governing the model's behavior. 
Like predicate abstraction, they produce models that over-approximate the behavior of the model they are applied to (i.e., $\beh(R(M)) \supset \beh(M)$).
However, the new behavior they introduce might not be spurious. 
We demonstrate such a case in Section ???.
If model checking returns a counter-example on $R(M)$, the physician can decide whether this is actually physiologically plausible behavior and therefore the pacemaker needs to be debugged, or this is indeed spurious and should be thrown out (and the abstraction refined).

Note this is different from classical predicate abstraction [???], which adds behavior in a domain-agnostic fashion. In fact, predicate abstraction is a fist step in the timed automata model checking procedure as presented in [ALur and Dill 1994].
Our abstraction rules are used to combine and and abstract models \emph{prior} to model checking.
%
%In typical formal verification practice, when the state space of a model $M$ is too large, \emph{predicate abstraction} is used to reduce the size of the state space while still preserving all the behavior of the original model. 
%This reduction in size may allow model checking where it wasn't possible before. 
%Because the abstract model $M'$ also introduces new behavior that didn't exist in the ground truth $M$, this new behavior is rejected as \emph{spurious} if it is encountered, and the abstraction is refined.
%This is the familiar CEGAR procedure[???].

Because we start from a set of initial models, and use a set of abstraction rules, we actually produce an \emph{abstraction tree} rather than an abstraction chain.
We demonstrate the construction and use of such a tree for the formal verification of pacemakers in Section ???

\subsubsection{Contributions}
In this paper we propose a framework for environment modeling and model checking of medical device software, in particular, pacemakers.
Specifically, we present several extended timed automata models of various heart conditions in Section ???. 
We define domain-specific abstraction rules for these models, and demonstrate how these can be applied to gradually add physiologically meaningful behavior in Section ???. 
Using the models and the rules, we build an abstraction tree which serves to perform model checking of physiological requirements for the heart+pacemaker closed loop in Section ???.
We illustrate the approach via case studies in Section ???, and conclude in Section ???

