\section{Introduction}
\label{introduction}

Implantable medical devices like pacemakers are designed to improve certain undesired physiological conditions with very little human interventions. Their capability of autonomously affecting the physiological conditions of the patients makes the medical devices safety-critical, and sufficient evidence on the safety and efficacy of the devices should be provided before the devices can be implanted in the patients. As more functions added to the devices, the complexity of the software component of the device is increasing dramatically, leading to increasing number of potential safety violations due to software bugs. 

There are two categories Since the requirements describe the intended behaviors of the closed-loop system consists of the environment and the system, verifying whether the specifications of the system satisfy the requirements requires closed-loop verification. 
%\todo[inline]{reserve the word `verification' for formal verification, and use `validation' when talking more generally}
In the medical device industry, closed-loop verification is performed in the form of clinical trials in which the devices are tested on the real patients. Clinical trials can only cover very limited environmental conditions due to extremely high cost. Moreover, clinical trials are often conducted at the last design stage. Fixing bugs at this stage is also very costly.

Model-based design has been proposed to speed up system software design and provide sufficient safety maintaining the safety promises in software requirement. It can potentially enable closed-loop verification of the software requirements at an earlier stage thus reduce cost. In a model-based design framework, the system software is first designed as an abstract model. Together with an environment model the closed-loop system can be verified against software requirements using model-checking techniques. The verified system model can then be rigorously translated into the software implementation (semi-)automatically so that the software implementation also satisfies all the software requirements.
%The software and its environment have very different properties that modeling them requires very different focuses. The software is generally a control graph which is generally deterministic given with physics and computations are two different things.

One of the biggest challenge for model-based design is to manage how much detail a model should have during model checking. In general the model should be abstract enough to ignore unnecessary details in order to reduce computational cost, but also detailed enough to distinguish execution paths that 1) satisfy/violate a property, and/or 2) are valid/invalid due to the extra behaviors introduced during model abstraction/approximation. These ambiguities must be removed from model to prevent false positives/negatives during model checking. 
%\subsection{Challenges}
%In this paper, we address the following four challenges that stand in the way of applying formal methods to the problem of verifying the correct functioning of pacemakers and other implantable cardiac devices.
%
%\begin{enumerate}
	%\item There are no formal models of the human heart's behavior.
	%\item There is a wide variety of distinct heart conditions, many of which are ill- or incompletely understood.
	%This results in the a priori need to create many heart models.
	%\item The physiological requirements are worded in the language of physicians and medical practitioners, so there is a need to express these requirements formally.
	%\item A related challenge is that these requirements are often vague, in the sense that a violation of the requirement does not necessarily indicate a preventable issue or a bug in the pacemaker. 
	%Thus there is a need to transmit back our findings to the physicians and device manufacturers who can decide whether the found counter-example is a bug or not.
%\end{enumerate}
%
%\todo[inline]{Question to be resolved: why is the application of abstraction rules preferred to `regular' predicate-based abstraction?}

\subsection{The Model Checking Problem}
\label{MCproblem}
\todo[inline]{This section is too long. Reduce to half a page. Also, doesn't belong in the introduction.}
%Model-based design enables closed-loop verification at an early design stage. 
For a model $M$ with state space $S$, we define the behavior of the model as an execution trace in $\delta\in S^*$. The reachable behavior space of model $M$ is denoted as $\mathbb{B}(M)\subset S^*$. A property $\varphi$ defines a region in the behavior space within which the property is satisfied, which can be denoted as $\mathbb{B}(\varphi)$. A model checking problem is to use mathematical tool to explore the whole reachable behaviors of a model $M$ against a property $\varphi$ such that $\mathbb{B}(M)\subseteq \mathbb{B}(\varphi)$. We denote it as $M\models\varphi$. Property violations should be returned as execution traces $\delta_v$ so that the designer can analyze and address the problem. 

\subsection{Model Abstraction with Over-approximation}
The behavior space of the actual system is too large for model checker to exhaustively explore. A model of the system which covers all behaviors of the system can be developed which can not only reduce complexity, but also having the suitable formalism for the model checker. An abstraction function $h$ abstracting model $M$ to $M'$ is a non-surjective function from state space $S$ to the new abstract state space $S'$ such that: 
$$\forall s\in S, \exists s'\in S' \text{ s.t. } h(s)=s'$$
This definition can be extended to behaviors $\delta\in \mathbb{B}(M)$, such that:
$$\forall \delta\in \mathbb{B}(M),\exists \delta'\in\mathbb{B}(M')\text{ s.t. } h(\delta)=h(\delta')$$
From the definition, we know that the abstract model $M'$ covers all behaviors of $M$, which is referred to as \emph{over-approximation}. We represent the over-approximation relationship as $M'\models M$, and the relationship between reachable behavior spaces as $\mathbb{B}(M)\subset_a\mathbb{B}(M')$. Then we have:
$$\mathbb{B}(M')\subseteq_a \mathbb{B}(M),\mathbb{B}(M)\subseteq_a \mathbb{B}(\varphi)\rightarrow\mathbb{B}(M')\subseteq_a \mathbb{B}(\varphi)\rightarrow M_t\models\varphi$$
Since the properties are preserved In general the state space of $S'$ is smaller than $S$ while still preserve the property, during model checking the more abstract model can be used to check the property. 

\subsubsection{Context Ambiguities}
\todo[inline]{why give new names to familiar things? Especially since these names don't make sense at this point. E.g. you speak of validity ambiguity, but it is not at all clear what is being validated and why the equation expresses an `ambiguity'. This is basically a description of what happens when abstracting, which most formal people are familiar with, so merge with section \ref{MCproblem}}

Since $h$ is non-surjective, certain states in $S$ will not be distinguishable in $S'$:
$$\exists s_1,s_2\in S \text{ s.t. }h(s_1)=h(s_2)=s',s'\in S'$$
For behaviors we have:
$$\exists \delta_1,\delta_2\in \mathbb{B}(M) \text{ s.t. }h(\delta_1)=h(\delta_2)=\delta',\delta'\in \mathbb{B}(M')$$
In the abstract model $\delta_1$ and $\delta_2$ are not distinguishable

\textbf{Validity Ambiguities}
However since $h$ is non-surjective, there exists behaviors in $M'$ that do not exists in the original model $M$:
$$\exists\delta'\in\mathbb{B}(M')\text{ s.t. }h^{-1}(\delta')\not\subset\mathbb{B}(M)$$

\subsubsection{System Model vs. Environment Model}
\subsection{Closed-loop Model Checking}
%During the software development process, there are two key documents that track the safety and efficacy of the software component, namely the \textbf{Software Requirements} and \textbf{Software Specifications}. These two terms are sometimes used interchangeably, however, requirements and specifications provides different angle of system safety and require very different verification techniques.
%
%A requirement states the objective of the system in design in terms of environmental conditions. For example, a requirement of a self-driving car would be: \emph{The car should not hit a pedestrian.} A specification is how the system developers propose to satisfy the requirements. For example, the specification corresponding to the requirement of a self-driving car would be: \emph{If an object is detected in front of the car and the distance to the object is less than $d$, the car should brake.} As we can see, a specification may not satisfy the corresponding requirement, thus two steps are required to guarantee the safety of the system software. The first is the conformance between the system software and the software specification. The second one is whether the software specifications can satisfy all the software requirements.
%
%Currently in most system design, the conformance between the software specifications and the system software are verified using extensive \textbf{open-loop} testing. The test cases are extracted from the system software using static analysis based on certain coverage criteria. The conformance between the specifications and the requirements are maintained by traceability documents, which is insufficient for safety guarantee.
% \begin{figure}[!t]
% 		\centering
% 		\includegraphics[width=0.8\textwidth]{figs/SysVSEnv.png}
% 		%\vspace{-5pt}
% 		\caption{\small Modeling in terms of behavior coverage. As model becomes more abstract, the coverage increases while the boundary becomes more simple. (a) System modeling in which there is only one concrete system; (b) Environment modeling in which abstraction can be used to generalize different conditions}
% 		  %\vspace{-15pt}
% 		\label{fig:sys}
% \end{figure}
\begin{figure}[!t]
		\centering
		\includegraphics[width=0.8\textwidth]{figs/distinction.png}
		%\vspace{-5pt}
		\caption{\small }
		  %\vspace{-15pt}
		\label{fig:ambiguity}
\end{figure}
\begin{figure}[!t]
		\centering
		\includegraphics[width=0.8\textwidth]{figs/env_sys.png}
		%\vspace{-5pt}
		\caption{\small }
		  %\vspace{-15pt}
		\label{fig:distinction}
\end{figure}



\input{contributions}


%\paragraph{Notation}. For a positive integer $n$, $[n] = \{1,2,\ldots,n\}$.

%\input{formulation}
%\input{example}